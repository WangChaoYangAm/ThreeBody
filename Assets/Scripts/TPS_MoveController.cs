using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class TPS_MoveController : MonoBehaviour
{
    [Header("相机距离")]
    public float freeDistance = 2;
    [Header("相机最近距离")]
    public float minDistance = 0.5f;
    [Header("相机最远距离")]
    public float maxDistance = 20;
    [Header("是否可控制相机距离(鼠标中键)")]
    public bool canControlDistance = true;
    [Header("更改相机距离的速度")]
    public float distanceSpeed = 1;

    [Header("视角灵敏度")]
    public float rotateSpeed = 1;
    [Header("物体转向插值(灵敏度,取值为0到1)")]
    public float TargetBodyRotateLerp = 0.3f;
    [Header("需要转向的物体")]
    public GameObject TargetBody;//此脚本能操作转向的物体
    [Header("相机焦点物体")]
    public GameObject CameraPivot;//相机焦点物体  
    [Header("===锁敌===")]
    public GameObject lockTarget = null;
    public float lockSlerp = 1;
    public GameObject lockMark;
    private bool marked;

    [Header("是否可控制物体转向")]
    public bool CanControlDirection = true;
    [Header("俯角(0-89)")]
    public float maxDepression = 80;
    [Header("仰角(0-89)")]
    public float maxEvelation = 80;


    private Vector3 PredictCameraPosition;
    private Vector3 offset;
    private Vector3 wallHit;
    private GameObject tmpMark;
    // Use this for initialization
    void Start()
    {

        offset = transform.position - CameraPivot.transform.position+new Vector3(0.6f,0,0);
        if (TargetBody == null)
        {
            TargetBody = GameObject.FindGameObjectWithTag("Player");
            Debug.Log("未绑定目标物体，默认替换为Player标签的物体");
        }
        if (!CameraPivot)
        {
            Debug.LogError("未绑定相机焦点物体");
        }

    }

    void LockTarget()
    {
        if (lockTarget)
        {
            lockTarget = null;
            marked = false;
            Destroy(tmpMark);
            return;
        }

        Vector3 top = transform.position + new Vector3(0, 1, 0) + transform.forward * 5;
        LayerMask mask = (1 << LayerMask.NameToLayer("Mob")); //将物体的Layer设置为Ignore Raycast,Player和Mob来忽略相机的射线，不然相机将跳到某些物体前,比如怪物,玩家等,

        Collider[] cols = Physics.OverlapBox(top, new Vector3(0.5f, 0.5f, 5), transform.rotation, mask);
        foreach (var col in cols)
        {
            lockTarget = col.gameObject;
        }
    }

    bool Inwall()
    {

        //RaycastHit hit;
        //LayerMask mask = (1 << LayerMask.NameToLayer("Player")) | (1 << LayerMask.NameToLayer("Ignore Raycast")) | (1 << LayerMask.NameToLayer("Mob")) | (1 << LayerMask.NameToLayer("Weapon")); //将物体的Layer设置为Ignore Raycast,Player和Mob来忽略相机的射线，不然相机将跳到某些物体前,比如怪物,玩家等,
        //mask = ~mask;//将以上的mask取反,表示射线将会忽略以上的层
        //             //Debug.DrawLine(CameraPivot.transform.position, transform.position - transform.forward, Color.red);

        //PredictCameraPosition = CameraPivot.transform.position + offset.normalized * freeDistance;//预测的相机位置
        //if (Physics.Linecast(CameraPivot.transform.position, PredictCameraPosition, out hit, mask))//碰撞到任意碰撞体,注意,因为相机没有碰撞器,所以是不会碰撞到相机的,也就是没有碰撞物时说明没有遮挡
        //{//也就是说，这个if就是指被遮挡的情况


        //    wallHit = hit.point;//碰撞点位置
        //    //Debug.DrawLine(transform.position, wallHit, Color.green);
        //    return true;
        //}
        //else//没碰撞到，也就是说没有障碍物
        //{
        //    return false;
        //}

        return false;
    }


    void FreeCamera()
    {
        offset = offset.normalized * freeDistance;
        transform.position = CameraPivot.transform.position + offset;//更新位置

        if (CanControlDirection)//控制角色方向开关
        {
            Quaternion TargetBodyCurrentRotation = TargetBody.transform.rotation;

            if (Input.GetKey(KeyCode.A))
            {
                if (Input.GetKey(KeyCode.W))
                {
                    TargetBody.transform.rotation = Quaternion.Lerp(TargetBodyCurrentRotation, Quaternion.Euler(new Vector3(TargetBody.transform.localEulerAngles.x, transform.localEulerAngles.y - 45, TargetBody.transform.localEulerAngles.z)), TargetBodyRotateLerp);
                }
                else if (Input.GetKey(KeyCode.S))
                {
                    TargetBody.transform.rotation = Quaternion.Lerp(TargetBodyCurrentRotation, Quaternion.Euler(new Vector3(TargetBody.transform.localEulerAngles.x, transform.localEulerAngles.y - 135, TargetBody.transform.localEulerAngles.z)), TargetBodyRotateLerp);
                }


                else if (!Input.GetKey(KeyCode.W) && !Input.GetKey(KeyCode.S))
                {
                    TargetBody.transform.rotation = Quaternion.Lerp(TargetBodyCurrentRotation, Quaternion.Euler(new Vector3(TargetBody.transform.localEulerAngles.x, transform.localEulerAngles.y - 90, TargetBody.transform.localEulerAngles.z)), TargetBodyRotateLerp);
                }
            }
            else if (Input.GetKey(KeyCode.D))
            {
                if (Input.GetKey(KeyCode.W))
                {
                    TargetBody.transform.rotation = Quaternion.Lerp(TargetBodyCurrentRotation, Quaternion.Euler(new Vector3(TargetBody.transform.localEulerAngles.x, transform.localEulerAngles.y + 45, TargetBody.transform.localEulerAngles.z)), TargetBodyRotateLerp);
                }
                else if (Input.GetKey(KeyCode.S))
                {
                    TargetBody.transform.rotation = Quaternion.Lerp(TargetBodyCurrentRotation, Quaternion.Euler(new Vector3(TargetBody.transform.localEulerAngles.x, transform.localEulerAngles.y + 135, TargetBody.transform.localEulerAngles.z)), TargetBodyRotateLerp);
                }

                else if (!Input.GetKey(KeyCode.W) && !Input.GetKey(KeyCode.S))
                {
                    TargetBody.transform.rotation = Quaternion.Lerp(TargetBodyCurrentRotation, Quaternion.Euler(new Vector3(TargetBody.transform.localEulerAngles.x, transform.localEulerAngles.y + 90, TargetBody.transform.localEulerAngles.z)), TargetBodyRotateLerp);
                }
            }
            else if (Input.GetKey(KeyCode.W))
            {
                TargetBody.transform.rotation = Quaternion.Lerp(TargetBodyCurrentRotation, Quaternion.Euler(new Vector3(TargetBody.transform.localEulerAngles.x, transform.localEulerAngles.y, TargetBody.transform.localEulerAngles.z)), TargetBodyRotateLerp);

            }
            else if (Input.GetKey(KeyCode.S))
            {
                TargetBody.transform.rotation = Quaternion.Lerp(TargetBodyCurrentRotation, Quaternion.Euler(new Vector3(TargetBody.transform.localEulerAngles.x, transform.localEulerAngles.y - 180, TargetBody.transform.localEulerAngles.z)), TargetBodyRotateLerp);

            }
        }

        if (canControlDistance)//控制距离开关
        {
            freeDistance -= Input.GetAxis("Mouse ScrollWheel") * distanceSpeed;
        }

        freeDistance = Mathf.Clamp(freeDistance, minDistance, maxDistance);

        if (!lockTarget)
        {


            transform.LookAt(lockTarget ? (lockTarget.transform.position) : CameraPivot.transform.position);
        }
        else
        {
            Quaternion tmp = Quaternion.Lerp(transform.rotation, Quaternion.LookRotation(lockTarget.transform.position - transform.position), lockSlerp * Time.fixedDeltaTime);
            transform.rotation = tmp;

        }

        float eulerX = transform.localEulerAngles.x;//相机的x欧拉角,也就是垂直方向.
        float inputY = Input.GetAxis("Mouse Y");


        if (!lockTarget)
        {
            //垂直视野限制
            if (!lockTarget)
            {
                transform.RotateAround(CameraPivot.transform.position, Vector3.up, rotateSpeed * Input.GetAxis("Mouse X"));//x不用限制
            }

            if (eulerX > maxDepression && eulerX < 90)//当向上角度越界时
            {
                if (inputY > 0)//如果鼠标时在向下滑动
                    transform.RotateAround(CameraPivot.transform.position, Vector3.right, -rotateSpeed * inputY);//允许滑动
            }
            else if (eulerX < 360 - maxEvelation && eulerX > 270)
            {
                if (inputY < 0)
                    transform.RotateAround(CameraPivot.transform.position, Vector3.right, -rotateSpeed * inputY);
            }
            else//角度正常时
            {

                transform.RotateAround(CameraPivot.transform.position, Vector3.right, -rotateSpeed * inputY);


            }
        }
        if (lockTarget)
        {
            offset = CameraPivot.transform.position - (lockTarget.transform.position);
        }
        else
        {
            offset = transform.position - CameraPivot.transform.position;//以上方向发生了变化,记录新的方向向量
        }

        offset = offset.normalized * freeDistance;

        ///在一次FixedUpdate中,随时记录新的旋转后的位置,然后得到方向,然后判断是否即将被遮挡,如果要被遮挡,将相机移动到计算后的不会被遮挡的位置
        ///如果不会被遮挡,则更新位置为相机焦点位置+方向的单位向量*距离
        ///
        if (Inwall())//预测会被遮挡
        {
            //print("Inwall");

            transform.position = CameraPivot.transform.position + (wallHit - CameraPivot.transform.position) * 0.8f;

            return;


        }
        else
        {
            transform.position = CameraPivot.transform.position + offset;

        }

    }

    // Update is called once per frame
    void FixedUpdate()
    {
        FreeCamera();
        if (lockTarget)
        {

            if (!marked)
            {
                tmpMark = Instantiate(lockMark, lockTarget.transform.position + new Vector3(0, 2.5f, 0), transform.rotation);
                tmpMark.transform.forward = -Vector3.up;
                marked = true;
            }

            else
            {
                tmpMark.transform.position = lockTarget.transform.position + new Vector3(0, 2.5f, 0);
                //tmpMark.transform.forward= -transform.up;
                tmpMark.transform.Rotate(Vector3.up * 30 * Time.fixedDeltaTime, Space.World);
            }
        }
    }

    private void Update()
    {
        if (Input.GetKeyDown(KeyCode.F))
        {
            LockTarget();
        }
    }

//――――――――――――――――
//版权声明：本文为CSDN博主「云上空」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
//原文链接：https://blog.csdn.net/qq_37724011/article/details/80292500

}
